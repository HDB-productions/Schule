
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Trainer für Flächenberechnungen</title>
    <style>
        :root {
            color-scheme: light dark;
            --bg: #f5f6ff;
            --fg: #0f1526;
            --card: #ffffffec;
            --accent: #4c7cf0;
            --accent-dark: #2646a6;
            --muted: #6f7799;
            --border: #dbe2f4;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #0f111d;
                --fg: #eff1ff;
                --card: #161a2d;
                --accent: #6f9cff;
                --accent-dark: #96b1ff;
                --muted: #aab2d7;
                --border: #242842;
            }
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: "Segoe UI", "Inter", system-ui, sans-serif;
            background: var(--bg);
            color: var(--fg);
            line-height: 1.6;
        }

        main {
            max-width: 1100px;
            margin: 0 auto;
            padding: 2.5rem 1.5rem 3rem;
        }

        .card {
            background: var(--card);
            border-radius: 18px;
            padding: 1.4rem;
            border: 1px solid var(--border);
            box-shadow: 0 24px 60px rgba(0, 0, 0, 0.08);
        }

        h1 {
            margin: 0;
            font-size: clamp(1.8rem, 4vw, 2.7rem);
        }

        .header-row {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: .5rem;
        }

.settings-toggle {
    line-height: 1;
    width: 46px;          /* wieder schön kompakt & rund */
    height: 46px;
    border-radius: 50%;
    border: 1px solid var(--border);
    background: var(--card);
    color: var(--fg);
    display: grid;
    place-items: center;
    font-size: 1.35rem;
    cursor: pointer;
    transition: transform .15s ease, box-shadow .15s ease;
}

/* Feinjustierung des Emojis in X-Richtung */
.settings-icon {
    display: inline-block;
    transform: translateX(-8px);
}

        .settings-toggle:active {
            transform: scale(0.95);
        }

        .settings-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(5, 7, 18, 0.45);
            backdrop-filter: blur(2px);
            z-index: 50;
        }

        .settings-panel {
            position: fixed;
            top: 2.5rem;
            right: 2.5rem;
            width: min(360px, calc(100% - 2rem));
            z-index: 60;
        }

        .settings-panel.hidden,
        .settings-backdrop.hidden {
            display: none;
        }

        .settings-group {
            margin-bottom: 1.25rem;
        }

        .settings-group h3 {
            margin: 0 0 .5rem;
            font-size: 1rem;
        }

        .settings-group label {
            display: flex;
            align-items: center;
            gap: .6rem;
            font-size: .95rem;
            margin-bottom: .3rem;
        }

        input[type="checkbox"],
        input[type="radio"] {
            width: 1.1rem;
            height: 1.1rem;
        }

        button {
            font: inherit;
            border: none;
            border-radius: 14px;
            padding: .85rem 1.4rem;
            cursor: pointer;
            transition: transform .15s ease, box-shadow .15s ease, opacity .2s ease;
        }

        button.primary {
            background: linear-gradient(120deg, var(--accent), var(--accent-dark));
            color: #fff;
            box-shadow: 0 12px 22px rgba(76, 124, 240, .35);
        }

        button.ghost {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--fg);
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed;
            box-shadow: none;
        }

        button:not(:disabled):active {
            transform: translateY(1px);
        }

        .status-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin: 1.5rem 0;
            color: var(--muted);
            font-weight: 600;
        }

        .status-pill {
            padding: .4rem .85rem;
            border-radius: 999px;
            background: rgba(76, 124, 240, 0.15);
            color: var(--accent-dark);
        }

        .task-card {
            display: flex;
            flex-wrap: wrap;
            gap: 1.6rem;
        }

        .task-text {
            flex: 1 1 280px;
        }

        .drawing {
            flex: 1 1 320px;
            min-height: 220px;
            border-radius: 16px;
            padding: .75rem;
            background: radial-gradient(circle at top, rgba(76,124,240,.20), transparent 70%);
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .given-values {
            list-style: none;
            padding: 0;
            margin: .9rem 0 0;
            display: grid;
            gap: .35rem;
        }

        .given-values li {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            padding-bottom: .25rem;
            border-bottom: 1px dashed var(--border);
            font-size: .95rem;
        }

        .given-symbol {
            font-weight: 600;
            letter-spacing: 0.04em;
        }

        .given-side-label {
            font-weight: 600;
        }

        .side-selection {
            margin-top: 1.1rem;
            border: 1px dashed var(--border);
            border-radius: 14px;
            padding: .9rem;
            background: rgba(76, 124, 240, 0.05);
        }

        .side-selection h3 {
            margin: 0 0 .4rem;
            font-size: 1rem;
        }

        .side-selection-fields {
            display: grid;
            gap: .6rem;
        }

        .side-select {
            display: flex;
            flex-direction: column;
            gap: .2rem;
            font-size: .95rem;
        }

        .side-select select {
            border-radius: 10px;
            border: 1px solid var(--border);
            padding: .45rem .7rem;
            font-size: 1rem;
            background: var(--bg);
            color: var(--fg);
        }

        .side-selection-message {
            margin-top: .4rem;
            font-size: .9rem;
            font-weight: 600;
        }

        .side-selection.success {
            border-color: #0c915a;
        }

        .side-selection.error {
            border-color: #c62828;
        }

        .answer-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 1rem;
            align-items: end;
        }

        input[type="text"] {
            width: 100%;
            padding: .85rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--fg);
            font-size: 1.05rem;
        }

        .unit-label {
            position: absolute;
            right: .9rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--muted);
            font-weight: 600;
        }

        .answer-input {
            position: relative;
        }

        .answer-buttons {
            display: flex;
            gap: .75rem;
            flex-wrap: wrap;
        }

        .feedback {
            min-height: 2.4rem;
            margin-top: 1rem;
            font-weight: 600;
        }

        .feedback.good {
            color: #0c915a;
        }

        .feedback.bad {
            color: #c62828;
        }

        .history {
            margin-top: 2.2rem;
        }

        .history ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: .45rem;
        }

        .history li {
            display: flex;
            justify-content: space-between;
            padding: .8rem 1rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            font-size: .95rem;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 640px) {
            .settings-panel {
                top: 1.5rem;
                right: 1rem;
                width: calc(100% - 2rem);
            }
        }
    </style>
</head>
<body>
<main>
    <div class="header-row">
        <div>
            <h1>Trainer für Flächenberechnungen</h1>
            <p>Übe Rechteck, Dreieck, Parallelogramm und Trapez: Wähle aus, welche Figuren und welche gesuchte Größe
                abgefragt werden und lasse dir zufällige Aufgaben generieren.</p>
        </div>
<button id="settingsBtn" class="settings-toggle" aria-label="Einstellungen">
    <span class="settings-icon">⚙</span>
</button>
    </div>

    <div id="settingsBackdrop" class="settings-backdrop hidden"></div>
    <section id="settingsPanel" class="settings-panel card hidden" aria-label="Einstellungen">
        <div class="settings-group">
            <h3>Flächentypen</h3>
            <label><input type="checkbox" name="shape" value="rectangle" checked> Rechteck</label>
            <label><input type="checkbox" name="shape" value="triangle" checked> Dreieck</label>
            <label><input type="checkbox" name="shape" value="parallelogram" checked> Parallelogramm</label>
            <label><input type="checkbox" name="shape" value="trapezoid" checked> Trapez</label>
        </div>
        <div class="settings-group">
            <h3>Gesuchte Größe</h3>
            <label><input type="checkbox" name="target" value="area" checked> Fläche A</label>
            <label><input type="checkbox" name="target" value="base" checked> Grundseite g</label>
            <label><input type="checkbox" name="target" value="height" checked> Höhe h</label>
            <label><input type="checkbox" name="target" value="longBase" checked> längere Grundseite</label>
            <label><input type="checkbox" name="target" value="shortBase" checked> kürzere Grundseite</label>
        </div>
        <div class="settings-group">
            <h3>Trainingsmodus</h3>
            <label><input type="radio" name="mode" value="training" checked> Training (mit Hilfen)</label>
            <label><input type="radio" name="mode" value="challenge"> Prüfung (1 Versuch)</label>
            <label><input type="radio" name="mode" value="timer"> Zeitrennen (30 s)</label>
        </div>
        <button id="closeSettings" class="primary" style="width: 100%;">Fertig</button>
    </section>

    <section class="status-bar">
        <div id="modeInfo">Training: Hinweise sind aktiv.</div>
        <div id="timerDisplay" class="status-pill hidden">⏱ 30 s</div>
        <div id="streakDisplay" class="status-pill">Serie: 0</div>
    </section>

    <section class="card task-card">
        <div class="task-text">
            <h2 id="taskTitle">Starte mit einer neuen Aufgabe</h2>
            <p id="taskPrompt">Tippe auf "Neue Aufgabe", um loszulegen.</p>
            <ul id="givenValues" class="given-values"></ul>
            <div id="sideSelection" class="side-selection hidden">
                <h3>Ordne die Variablen zu</h3>
                <div id="sideSelectionFields" class="side-selection-fields"></div>
                <p id="sideSelectionMessage" class="side-selection-message"></p>
            </div>
            <div id="formulaHint" class="hidden"></div>
        </div>
        <div id="shapeDrawing" class="drawing">
            <svg viewBox="0 0 220 180" aria-hidden="true">
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted)">
                    SVG Vorschau
                </text>
            </svg>
        </div>
    </section>

    <section class="card">
        <div class="answer-area">
            <div>
                <label for="answerInput">Dein Ergebnis</label>
                <div class="answer-input">
                    <input type="text" id="answerInput" inputmode="decimal" placeholder="z. B. 42,5">
                    <span id="unitLabel" class="unit-label">cm²</span>
                </div>
            </div>
            <div class="answer-buttons">
                <button id="checkBtn" class="primary">Antwort prüfen</button>
                <button id="newTaskBtn" class="ghost">Neue Aufgabe</button>
                <button id="giveUpBtn" class="ghost">Aufgeben / Lösung</button>
            </div>
        </div>
        <p id="feedback" class="feedback"></p>
    </section>

    <section class="history card">
        <h2>Verlauf</h2>
        <ul id="historyList">
            <li>Noch keine Versuche.</li>
        </ul>
    </section>
</main>
<script>
    const formatNumber = (value, digits = 2) => {
        if (Number.isInteger(value)) return value.toString();
        return value.toFixed(digits).replace(".", ",").replace(/0+$/, "").replace(/,$/, "");
    };

    const randomValue = (min, max, step = 0.5) => {
        const steps = Math.round((max - min) / step);
        const raw = min + Math.round(Math.random() * steps) * step;
        return Math.round(raw * 100) / 100;
    };
    const roundMeasure = value => Math.round(value * 100) / 100;

    const shuffle = list => {
        const arr = [...list];
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
    };

    const units = ["cm", "m", "mm"];
    const letterPool = ["a", "b", "c", "d"];
    const letterColors = {
        a: "#e63946",
        b: "#ffbe0b",
        c: "#6d5dfc",
        d: "#ff7f11",
        h: "#2a9d8f"
    };
    const extraColors = {
        A: "#f4a261",
        α: "#6d5dfc",
        s: "#ffbe0b"
    };

    const targetLabels = {
        area: "A",
        base: "g",
        height: "h",
        longBase: "längere Grundseite",
        shortBase: "kürzere Grundseite"
    };

    const viewBox = { width: 220, height: 180, centerX: 110, centerY: 90 };
    const rotationOptions = [0, 90, 180, 270];
    const pickRotation = () => rotationOptions[Math.floor(Math.random() * rotationOptions.length)];
    const rotateTextAttr = (rotation, x, y) => rotation ? ` transform="rotate(${-rotation} ${x} ${y})"` : "";
    const getLetterColor = letter => letterColors[letter] || "#4c7cf0";
    const assignLetters = identifyList => {
        if (!identifyList?.length) return {};
        const shuffled = shuffle(letterPool);
        const mapping = {};
        identifyList.forEach((item, index) => {
            mapping[item.key] = shuffled[index % shuffled.length];
        });
        return mapping;
    };
    const getCustomMapping = shapeKey => {
        switch (shapeKey) {
            case "rectangle":
                return { base: "a", height: "b" };
            case "triangle": {
                const letters = shuffle(["a", "b", "c"]);
                return {
                    base: letters[0],
                    sideLeft: letters[1],
                    sideRight: letters[2],
                    height: "h"
                };
            }
            case "parallelogram": {
                const letters = shuffle(["a", "b", "c", "d"]);
                return {
                    base: letters[0],
                    side: letters[1],
                    height: "h"
                };
            }
            case "trapezoid": {
                const letters = shuffle(["a", "b", "c", "d"]);
                return {
                    baseA: letters[0],
                    legLeft: letters[1],
                    baseC: letters[2],
                    legRight: letters[3],
                    height: "h"
                };
            }
            default:
                return null;
        }
    };

    const createEntry = (key, label, value, unit, options = {}) => ({
        key,
        label,
        value,
        unit,
        type: options.type ?? "measure",
        display: options.display ?? null
    });

    const shapeConfig = {
        rectangle: {
            label: "Rechteck",
            formula: "A = a · b",
            targets: ["area", "base", "height"],
            generate(unit) {
                const base = randomValue(4, 24, 0.5);
                let height = randomValue(4, 24, 0.5);
                if (height === base) height += 0.5;
                return { unit, params: { base, height } };
            },
            area({ base, height }) {
                return base * height;
            },
            prepare(target, generated) {
                const { base, height } = generated.params;
                const unit = generated.unit;
                const areaValue = this.area(generated.params);
                const entries = {
                    area: {
                        prompt: "Berechne den Flächeninhalt A.",
                        given: [
                            createEntry("base", "Seite", base, unit, { type: "side" }),
                            createEntry("height", "Seite", height, unit, { type: "side" })
                        ],
                        unitSuffix: `${unit}²`,
                        correctValue: areaValue,
                        highlight: ["base", "height"],
                        hint: "A = a · b"
                    },
                    base: {
                        prompt: "Seite a ist gesucht.",
                        given: [
                            createEntry("height", "Seite", height, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" })
                        ],
                        unitSuffix: unit,
                        correctValue: base,
                        highlight: ["base", "height"],
                        hint: "a = A ÷ b"
                    },
                    height: {
                        prompt: "Seite b ist gesucht.",
                        given: [
                            createEntry("base", "Seite", base, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" })
                        ],
                        unitSuffix: unit,
                        correctValue: height,
                        highlight: ["base", "height"],
                        hint: "b = A ÷ a"
                    }
                };
                return entries[target];
            },
            draw(params, unit, highlight, mapping = {}) {
                const { base, height } = params;
                const scale = 5;
                const w = base * scale;
                const h = height * scale;
                const offsetX = (viewBox.width - w) / 2;
                const offsetY = (viewBox.height - h) / 2;
                const rotation = pickRotation();
                const left = offsetX;
                const right = offsetX + w;
                const top = offsetY;
                const bottom = offsetY + h;
                const baseLetter = mapping.base || letterPool[0];
                const heightLetter = mapping.height || letterPool[1];
                const baseColor = getLetterColor(baseLetter);
                const heightColor = getLetterColor(heightLetter);
                const baseLabelX = (left + right) / 2;
                const baseLabelY = bottom + 16;
                const heightLabelX = left - 14;
                const heightLabelY = (top + bottom) / 2;
                return `
                <svg viewBox="0 0 ${viewBox.width} ${viewBox.height}">
                    <g transform="rotate(${rotation} ${viewBox.centerX} ${viewBox.centerY})">
                        <rect x="${left}" y="${top}" width="${w}" height="${h}"
                              style="fill: rgba(76,124,240,.15); stroke: var(--accent); stroke-width: 2;" />
                        <line x1="${left}" y1="${bottom}" x2="${right}" y2="${bottom}"
                              style="stroke: ${baseColor}; stroke-width: 4; stroke-linecap: round;" />
                        <line x1="${left}" y1="${top}" x2="${left}" y2="${bottom}"
                              style="stroke: ${heightColor}; stroke-width: 4; stroke-linecap: round;" />
                        <text x="${baseLabelX}" y="${baseLabelY}" text-anchor="middle"
                              ${rotateTextAttr(rotation, baseLabelX, baseLabelY)}
                              style="fill: ${baseColor}; font-weight: 600;">${baseLetter}</text>
                        <text x="${heightLabelX}" y="${heightLabelY}" text-anchor="middle"
                              ${rotateTextAttr(rotation, heightLabelX, heightLabelY)}
                              style="fill: ${heightColor}; font-weight: 600;">${heightLetter}</text>
                    </g>
                </svg>`;
            }
        },
        triangle: {
            label: "Dreieck",
            formula: "A = (g · h) / 2",
            targets: ["area", "base", "height"],
            identify: () => [
                { key: "base", label: "Grundseite zu h" },
                { key: "height", label: "Höhe" }
            ],
            generate(unit) {
                const base = randomValue(6, 22, 0.5);
                const height = randomValue(4, 18, 0.5);
                const footRatio = Math.random() * 1.4 - 0.2;
                const leftHorizontal = Math.abs(base * footRatio);
                const rightHorizontal = Math.abs(base - base * footRatio);
                const sideLeft = roundMeasure(Math.sqrt(leftHorizontal * leftHorizontal + height * height));
                const sideRight = roundMeasure(Math.sqrt(rightHorizontal * rightHorizontal + height * height));
                return { unit, params: { base, height, footRatio, sideLeft, sideRight } };
            },
            area({ base, height }) {
                return (base * height) / 2;
            },
            prepare(target, generated) {
                const { base, height, sideLeft, sideRight } = generated.params;
                const unit = generated.unit;
                const areaValue = this.area(generated.params);
                const sharedSides = [
                    createEntry("sideLeft", "Seite", sideLeft, unit, { type: "side" }),
                    createEntry("sideRight", "Seite", sideRight, unit, { type: "side" })
                ];
                const entries = {
                    area: {
                        prompt: "Berechne den Flächeninhalt A.",
                        given: [
                            createEntry("base", "Seite", base, unit, { type: "side" }),
                            createEntry("height", "Höhe", height, unit, { type: "side" }),
                            ...sharedSides
                        ],
                        unitSuffix: `${unit}²`,
                        correctValue: areaValue,
                        highlight: ["base", "height"],
                        hint: "A = (g · h) : 2."
                    },
                    base: {
                        prompt: "Die zur Höhe gehörende Grundseite ist gesucht.",
                        given: [
                            createEntry("height", "Höhe", height, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" })
                        ],
                        unitSuffix: unit,
                        correctValue: base,
                        highlight: ["base", "height"],
                        hint: "Die Grundseite liegt an der eingezeichneten Höhe: g = (2 · A) ÷ h."
                    },
                    height: {
                        prompt: "Höhe ist gesucht.",
                        given: [
                            createEntry("base", "Seite", base, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" }),
                            ...sharedSides
                        ],
                        unitSuffix: unit,
                        correctValue: height,
                        highlight: ["base", "height"],
                        hint: "h = (2 · A) ÷ g."
                    }
                };
                return entries[target];
            },
            draw(params, unit, highlight, mapping = {}) {
                const { base, height, footRatio = 0.5 } = params;
                const scale = 5;
                const w = base * scale;
                const h = height * scale;
                const startX = (viewBox.width - w) / 2;
                const baseY = viewBox.height - 30;
                const apexX = startX + w * footRatio;
                const apexY = baseY - h;
                const rotation = pickRotation();
                const footX = apexX;
                const baseLetter = mapping.base || "a";
                const heightLetter = mapping.height || "h";
                const sideLeftLetter = mapping.sideLeft || "b";
                const sideRightLetter = mapping.sideRight || "c";
                const baseColor = getLetterColor(baseLetter);
                const heightColor = getLetterColor(heightLetter);
                const sideLeftColor = getLetterColor(sideLeftLetter);
                const sideRightColor = getLetterColor(sideRightLetter);
                const needsLeftHelper = footX < startX;
                const needsRightHelper = footX > startX + w;
                const helperLines = [];
                if (needsLeftHelper) {
                    helperLines.push(`<line x1="${footX}" y1="${baseY}" x2="${startX}" y2="${baseY}" style="stroke-dasharray: 6 4; stroke: ${baseColor}; stroke-width: 2;" />`);
                } else if (needsRightHelper) {
                    helperLines.push(`<line x1="${startX + w}" y1="${baseY}" x2="${footX}" y2="${baseY}" style="stroke-dasharray: 6 4; stroke: ${baseColor}; stroke-width: 2;" />`);
                }
                const baseMidX = (startX + startX + w) / 2;
                const baseLabelY = baseY + 18;
                const heightLabelX = footX + 10;
                const heightLabelY = (apexY + baseY) / 2;
                const leftMidX = (startX + apexX) / 2 - 6;
                const leftMidY = (baseY + apexY) / 2 - 6;
                const rightMidX = (startX + w + apexX) / 2 + 6;
                const rightMidY = (baseY + apexY) / 2 - 6;
                return `
                <svg viewBox="0 0 ${viewBox.width} ${viewBox.height}">
                    <g transform="rotate(${rotation} ${viewBox.centerX} ${viewBox.centerY})">
                        <polygon points="${startX},${baseY} ${startX + w},${baseY} ${apexX},${apexY}"
                                 style="fill: rgba(76,124,240,.15); stroke: var(--accent); stroke-width: 2;" />
                        ${helperLines.join("")}
                        <line x1="${startX}" y1="${baseY}" x2="${startX + w}" y2="${baseY}"
                              style="stroke: ${baseColor}; stroke-width: 3.5; stroke-linecap: round;" />
                        <line x1="${startX}" y1="${baseY}" x2="${apexX}" y2="${apexY}"
                              style="stroke: ${sideLeftColor}; stroke-width: 3; stroke-linecap: round;" />
                        <line x1="${startX + w}" y1="${baseY}" x2="${apexX}" y2="${apexY}"
                              style="stroke: ${sideRightColor}; stroke-width: 3; stroke-linecap: round;" />
                        <line x1="${apexX}" y1="${apexY}" x2="${footX}" y2="${baseY}"
                              style="stroke: ${heightColor}; stroke-width: 3.5; stroke-linecap: round;" />
                        <text x="${baseMidX}" y="${baseLabelY}" text-anchor="middle"
                              ${rotateTextAttr(rotation, baseMidX, baseLabelY)}
                              style="fill: ${baseColor}; font-weight: 600;">${baseLetter}</text>
                        <text x="${leftMidX}" y="${leftMidY}"
                              ${rotateTextAttr(rotation, leftMidX, leftMidY)}
                              style="fill: ${sideLeftColor}; font-weight: 600;">${sideLeftLetter}</text>
                        <text x="${rightMidX}" y="${rightMidY}"
                              ${rotateTextAttr(rotation, rightMidX, rightMidY)}
                              style="fill: ${sideRightColor}; font-weight: 600;">${sideRightLetter}</text>
                        <text x="${heightLabelX}" y="${heightLabelY}"
                              ${rotateTextAttr(rotation, heightLabelX, heightLabelY)}
                              style="fill: ${heightColor}; font-weight: 600;">${heightLetter}</text>
                    </g>
                </svg>`;
            }
        },
        parallelogram: {
            label: "Parallelogramm",
            formula: "A = g · h",
            targets: ["area", "base", "height"],
            identify: () => [
                { key: "base", label: "Grundseite" },
                { key: "height", label: "Höhe" }
            ],
            generate(unit) {
                const base = randomValue(6, 24, 0.5);
                const height = randomValue(4, 16, 0.5);
                let side = randomValue(height + 1, 22, 0.5);
                const angleRad = Math.asin(Math.min(0.98, height / side));
                const angleDeg = Math.round(angleRad * 180 / Math.PI);
                return { unit, params: { base, height, side, angleDeg } };
            },
            area({ base, height }) {
                return base * height;
            },
            prepare(target, generated) {
                const { base, height, side, angleDeg } = generated.params;
                const unit = generated.unit;
                const areaValue = this.area(generated.params);
                const sharedInfo = [
                    createEntry("side", "Seite", side, unit, { type: "side" })
                ];
                const entries = {
                    area: {
                        prompt: "Berechne den Flächeninhalt A.",
                        given: [
                            createEntry("base", "Seite", base, unit, { type: "side" }),
                            createEntry("height", "Höhe", height, unit, { type: "side" }),
                            ...sharedInfo
                        ],
                        unitSuffix: `${unit}²`,
                        correctValue: areaValue,
                        highlight: ["base", "height"],
                        hint: "A = g · h"
                    },
                    base: {
                        prompt: "Zu h gehörende Grundseite ist gesucht.",
                        given: [
                            createEntry("height", "Höhe", height, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" }),
                           
                        ],
                        unitSuffix: unit,
                        correctValue: base,
                        highlight: ["base", "height"],
                        hint: "g = A ÷ h"
                    },
                    height: {
                        prompt: "Höhe ist gesucht.",
                        given: [
                            createEntry("base", "Seite", base, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" }),
                            ...sharedInfo
                        ],
                        unitSuffix: unit,
                        correctValue: height,
                        highlight: ["base", "height"],
                        hint: "h = A ÷ g"
                    }
                };
                return entries[target];
            },
            draw(params, unit, highlight, mapping = {}) {
                const { base, height } = params;
                const scale = 4.6;
                const w = base * scale;
                const h = height * scale;
                const slant = (Math.random() * 1.1 - 0.55) * w;
                const minX = Math.min(0, slant);
                const maxX = Math.max(w, w + slant);
                const offsetX = (viewBox.width - (maxX - minX)) / 2 - minX;
                const baseY = viewBox.height - 28;
                const topY = baseY - h;
                const p1 = [offsetX, baseY];
                const p2 = [offsetX + w, baseY];
                const p3 = [offsetX + w + slant, topY];
                const p4 = [offsetX + slant, topY];
                const rotation = pickRotation();
                const baseLetter = mapping.base || "a";
                const heightLetter = mapping.height || "h";
                const sideLetter = mapping.side || "b";
                const baseColor = getLetterColor(baseLetter);
                const heightColor = getLetterColor(heightLetter);
                const sideColor = getLetterColor(sideLetter);
                const dropFromRight = Math.random() > 0.5;
                const anchor = dropFromRight ? p3 : p4;
                const footX = anchor[0];
                const helper = [];
                if (footX < p1[0]) {
                    helper.push(`<line x1="${footX}" y1="${baseY}" x2="${p1[0]}" y2="${baseY}" style="stroke-dasharray: 6 4; stroke: ${baseColor}; stroke-width: 2;" />`);
                } else if (footX > p2[0]) {
                    helper.push(`<line x1="${p2[0]}" y1="${baseY}" x2="${footX}" y2="${baseY}" style="stroke-dasharray: 6 4; stroke: ${baseColor}; stroke-width: 2;" />`);
                }
                const baseMidX = (p1[0] + p2[0]) / 2;
                const baseLabelY = baseY + 16;
                const heightLabelX = anchor[0] + 12;
                const heightLabelY = (anchor[1] + baseY) / 2;
                const sideMidX = (p1[0] + p4[0]) / 2 - 8;
                const sideMidY = (p1[1] + p4[1]) / 2;
                const polygonPoints = `${p1[0]},${p1[1]} ${p2[0]},${p2[1]} ${p3[0]},${p3[1]} ${p4[0]},${p4[1]}`;
                return `
                <svg viewBox="0 0 ${viewBox.width} ${viewBox.height}">
                    <g transform="rotate(${rotation} ${viewBox.centerX} ${viewBox.centerY})">
                        <polygon points="${polygonPoints}"
                                 style="fill: rgba(76,124,240,.15); stroke: var(--accent); stroke-width: 2;" />
                        ${helper.join("")}
                        <line x1="${p1[0]}" y1="${p1[1]}" x2="${p2[0]}" y2="${p2[1]}"
                              style="stroke: ${baseColor}; stroke-width: 3.5; stroke-linecap: round;" />
                        <line x1="${p4[0]}" y1="${p4[1]}" x2="${p1[0]}" y2="${p1[1]}"
                              style="stroke: ${sideColor}; stroke-width: 3; stroke-linecap: round;" />
                        <line x1="${anchor[0]}" y1="${anchor[1]}" x2="${footX}" y2="${baseY}"
                              style="stroke: ${heightColor}; stroke-width: 3.5; stroke-linecap: round;" />
                        <text x="${baseMidX}" y="${baseLabelY}" text-anchor="middle"
                              ${rotateTextAttr(rotation, baseMidX, baseLabelY)}
                              style="fill: ${baseColor}; font-weight: 600;">${baseLetter}</text>
                        <text x="${sideMidX}" y="${sideMidY}"
                              ${rotateTextAttr(rotation, sideMidX, sideMidY)}
                              style="fill: ${sideColor}; font-weight: 600;">${sideLetter}</text>
                        <text x="${heightLabelX}" y="${heightLabelY}"
                              ${rotateTextAttr(rotation, heightLabelX, heightLabelY)}
                              style="fill: ${heightColor}; font-weight: 600;">${heightLetter}</text>
                    </g>
                </svg>`;
            }
        },
        trapezoid: {
            label: "Trapez",
            formula: "A = ((a + c) / 2) · h",
            targets: ["area", "height", "longBase", "shortBase"],

identify: () => [
    { key: "baseA", label: "Grundseite (längerer Teil)" },
    { key: "baseC", label: "Grundseite (kürzerer Teil)" },
    { key: "height", label: "Höhe" }
            ],
            generate(unit) {
                const baseA = randomValue(12, 26, 0.5);
                const baseC = randomValue(6, baseA - 3, 0.5);
                const height = randomValue(4, 12, 0.5);
                const extra = Math.max(1.2, baseC * 0.4);
                const offset = randomValue(-extra, (baseA - baseC) + extra, 0.5);
                const leftOffset = offset;
                const rightOffset = baseA - (offset + baseC);
                const legLeft = roundMeasure(Math.sqrt(leftOffset * leftOffset + height * height));
                const legRight = roundMeasure(Math.sqrt(rightOffset * rightOffset + height * height));
                return { unit, params: { baseA, baseC, height, offset, legLeft, legRight } };
            },
            area({ baseA, baseC, height }) {
                return ((baseA + baseC) / 2) * height;
            },
            prepare(target, generated) {
                const { baseA, baseC, height, legLeft, legRight } = generated.params;
                const unit = generated.unit;
                const areaValue = this.area(generated.params);
                const sharedLegs = [
                    createEntry("legLeft", "Seite", legLeft, unit, { type: "side" }),
                    createEntry("legRight", "Seite", legRight, unit, { type: "side" })
                ];
                const entries = {
                    area: {
                        prompt: "Berechne den Flächeninhalt A.",
                        given: [
                            createEntry("baseA", "Seite", baseA, unit, { type: "side" }),
                            createEntry("baseC", "Seite", baseC, unit, { type: "side" }),
                            createEntry("height", "Höhe", height, unit, { type: "side" }),
                            ...sharedLegs
                        ],
                        unitSuffix: `${unit}²`,
                        correctValue: areaValue,
                        highlight: ["baseA", "baseC", "height"],
                        hint: "A = ((a + c) / 2) · h"
                    },
                    height: {
                        prompt: "Höhe h ist gesucht.",
                        given: [
                            createEntry("baseA", "Seite", baseA, unit, { type: "side" }),
                            createEntry("baseC", "Seite", baseC, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" }),
                            ...sharedLegs
                        ],
                        unitSuffix: unit,
                        correctValue: height,
                        highlight: ["baseA", "baseC", "height"],
                        hint: "h = (2 · A) ÷ (a + c)"
                    },
                    longBase: {
                        prompt: "Die längere Grundseite ist gesucht.",
                        given: [
                            createEntry("baseC", "Seite", baseC, unit, { type: "side" }),
                            createEntry("height", "Höhe", height, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" }),
                            ...sharedLegs
                        ],
                        unitSuffix: unit,
                        correctValue: baseA,
                        highlight: ["baseA", "baseC", "height"],
                        hint: "a = (2 · A ÷ h) - c"
                    },
                    shortBase: {
                        prompt: "Die kürzere Grundseite ist gesucht.",
                        given: [
                            createEntry("baseA", "Seite", baseA, unit, { type: "side" }),
                            createEntry("height", "Höhe", height, unit, { type: "side" }),
                            createEntry("area", "Fläche", areaValue, `${unit}²`, { display: "A" }),
                            ...sharedLegs
                        ],
                        unitSuffix: unit,
                        correctValue: baseC,
                        highlight: ["baseA", "baseC", "height"],
                        hint: "c = (2 · A ÷ h) - a"
                    }
                };
                return entries[target];
            },
            draw(params, unit, highlight, mapping = {}) {
                const { baseA, baseC, height, offset = (baseA - baseC) / 2 } = params;
                const scale = 4.4;
                const a = baseA * scale;
                const c = baseC * scale;
                const h = height * scale;
                const baseY = viewBox.height - 26;
                const startX = (viewBox.width - a) / 2;
                const topStartX = startX + offset * scale;
                const rotation = pickRotation();
                const baseALetter = mapping.baseA || "a";
                const baseCLetter = mapping.baseC || "c";
                const heightLetter = mapping.height || "h";
                const legLeftLetter = mapping.legLeft || "b";
                const legRightLetter = mapping.legRight || "d";
                const baseAColor = getLetterColor(baseALetter);
                const baseCColor = getLetterColor(baseCLetter);
                const heightColor = getLetterColor(heightLetter);
                const legLeftColor = getLetterColor(legLeftLetter);
                const legRightColor = getLetterColor(legRightLetter);
                const p1 = [startX, baseY];
                const p2 = [startX + a, baseY];
                const p3 = [topStartX + c, baseY - h];
                const p4 = [topStartX, baseY - h];
                const anchor = Math.random() > 0.5 ? p3 : p4;
                const footX = anchor[0];
                const helper = [];
                if (footX < p1[0]) {
                    helper.push(`<line x1="${footX}" y1="${baseY}" x2="${p1[0]}" y2="${baseY}" style="stroke-dasharray: 6 4; stroke: ${baseAColor}; stroke-width: 2;" />`);
                } else if (footX > p2[0]) {
                    helper.push(`<line x1="${p2[0]}" y1="${baseY}" x2="${footX}" y2="${baseY}" style="stroke-dasharray: 6 4; stroke: ${baseAColor}; stroke-width: 2;" />`);
                }
                const baseABottomY = baseY + 14;
                const baseCTopY = p4[1] - 14;
                const heightLabelX = anchor[0] + 12;
                const heightLabelY = (anchor[1] + baseY) / 2;
                const leftLegMidX = (p1[0] + p4[0]) / 2 - 8;
                const leftLegMidY = (p1[1] + p4[1]) / 2;
                const rightLegMidX = (p2[0] + p3[0]) / 2 + 8;
                const rightLegMidY = (p2[1] + p3[1]) / 2;
                return `
                <svg viewBox="0 0 ${viewBox.width} ${viewBox.height}">
                    <g transform="rotate(${rotation} ${viewBox.centerX} ${viewBox.centerY})">
                        <polygon points="${p1[0]},${p1[1]} ${p2[0]},${p2[1]} ${p3[0]},${p3[1]} ${p4[0]},${p4[1]}"
                                 style="fill: rgba(76,124,240,.15); stroke: var(--accent); stroke-width: 2;" />
                        ${helper.join("")}
                        <line x1="${p1[0]}" y1="${baseABottomY}" x2="${p2[0]}" y2="${baseABottomY}"
                              style="stroke: ${baseAColor}; stroke-width: 3.5; stroke-linecap: round;" />
                        <line x1="${p4[0]}" y1="${baseCTopY}" x2="${p3[0]}" y2="${baseCTopY}"
                              style="stroke: ${baseCColor}; stroke-width: 3.5; stroke-linecap: round;" />
                        <line x1="${p1[0]}" y1="${p1[1]}" x2="${p4[0]}" y2="${p4[1]}"
                              style="stroke: ${legLeftColor}; stroke-width: 3; stroke-linecap: round;" />
                        <line x1="${p2[0]}" y1="${p2[1]}" x2="${p3[0]}" y2="${p3[1]}"
                              style="stroke: ${legRightColor}; stroke-width: 3; stroke-linecap: round;" />
                        <line x1="${anchor[0]}" y1="${anchor[1]}" x2="${footX}" y2="${baseY}"
                              style="stroke: ${heightColor}; stroke-width: 3.5; stroke-linecap: round;" />
                        <text x="${(p1[0] + p2[0]) / 2}" y="${baseABottomY + 16}" text-anchor="middle"
                              ${rotateTextAttr(rotation, (p1[0] + p2[0]) / 2, baseABottomY + 16)}
                              style="fill: ${baseAColor}; font-weight: 600;">${baseALetter}</text>
                        <text x="${(p3[0] + p4[0]) / 2}" y="${baseCTopY - 10}" text-anchor="middle"
                              ${rotateTextAttr(rotation, (p3[0] + p4[0]) / 2, baseCTopY - 10)}
                              style="fill: ${baseCColor}; font-weight: 600;">${baseCLetter}</text>
                        <text x="${leftLegMidX}" y="${leftLegMidY}"
                              ${rotateTextAttr(rotation, leftLegMidX, leftLegMidY)}
                              style="fill: ${legLeftColor}; font-weight: 600;">${legLeftLetter}</text>
                        <text x="${rightLegMidX}" y="${rightLegMidY}"
                              ${rotateTextAttr(rotation, rightLegMidX, rightLegMidY)}
                              style="fill: ${legRightColor}; font-weight: 600;">${legRightLetter}</text>
                        <text x="${heightLabelX}" y="${heightLabelY}"
                              ${rotateTextAttr(rotation, heightLabelX, heightLabelY)}
                              style="fill: ${heightColor}; font-weight: 600;">${heightLetter}</text>
                    </g>
                </svg>`;
            }
        }
    };
    const modes = {
        training: {
            label: "Training",
            description: "Hinweise eingeblendet, mehrere Versuche",
            timer: null,
            maxAttempts: Infinity,
            showHints: true
        },
        challenge: {
            label: "Prüfung",
            description: "Nur ein Versuch pro Aufgabe",
            timer: null,
            maxAttempts: 1,
            showHints: false
        },
        timer: {
            label: "Zeitrennen",
            description: "30 Sekunden pro Aufgabe",
            timer: 30,
            maxAttempts: Infinity,
            showHints: false
        }
    };

    const state = {
        settings: {
            shapes: new Set(["rectangle", "triangle", "parallelogram", "trapezoid"]),
            targets: new Set(["area", "base", "height", "longBase", "shortBase"]),
            mode: "training"
        },
        currentTask: null,
        correctValue: null,
        unitSuffix: "cm²",
        attempts: 0,
        streak: 0,
        timerId: null,
        timeLeft: 0,
        history: [],
        solved: false,
        mappingSolved: false,
        userSelections: {}
    };

    const elements = {
        settingsBtn: document.getElementById("settingsBtn"),
        settingsPanel: document.getElementById("settingsPanel"),
        settingsBackdrop: document.getElementById("settingsBackdrop"),
        closeSettings: document.getElementById("closeSettings"),
        givenValues: document.getElementById("givenValues"),
        taskTitle: document.getElementById("taskTitle"),
        taskPrompt: document.getElementById("taskPrompt"),
        drawing: document.getElementById("shapeDrawing"),
        formulaHint: document.getElementById("formulaHint"),
        unitLabel: document.getElementById("unitLabel"),
        answerInput: document.getElementById("answerInput"),
        checkBtn: document.getElementById("checkBtn"),
        newTaskBtn: document.getElementById("newTaskBtn"),
        giveUpBtn: document.getElementById("giveUpBtn"),
        feedback: document.getElementById("feedback"),
        historyList: document.getElementById("historyList"),
        modeInfo: document.getElementById("modeInfo"),
        timerDisplay: document.getElementById("timerDisplay"),
        streakDisplay: document.getElementById("streakDisplay"),
        sideSelection: document.getElementById("sideSelection"),
        sideSelectionFields: document.getElementById("sideSelectionFields"),
        sideSelectionMessage: document.getElementById("sideSelectionMessage")
    };

    const shapeCheckboxes = Array.from(document.querySelectorAll('input[name="shape"]'));
    const targetCheckboxes = Array.from(document.querySelectorAll('input[name="target"]'));
    const modeRadios = Array.from(document.querySelectorAll('input[name="mode"]'));

    function toggleSettings(open) {
        const shouldOpen = open ?? elements.settingsPanel.classList.contains("hidden");
        elements.settingsPanel.classList.toggle("hidden", !shouldOpen);
        elements.settingsBackdrop.classList.toggle("hidden", !shouldOpen);
    }

    function ensureAtLeastOne(set, checkbox) {
        if (set.size === 0) {
            set.add(checkbox.value);
            checkbox.checked = true;
            return false;
        }
        return true;
    }

    shapeCheckboxes.forEach(cb => {
        cb.addEventListener("change", () => {
            if (cb.checked) {
                state.settings.shapes.add(cb.value);
            } else {
                state.settings.shapes.delete(cb.value);
                if (!ensureAtLeastOne(state.settings.shapes, cb)) {
                    return;
                }
            }
        });
    });

    targetCheckboxes.forEach(cb => {
        cb.addEventListener("change", () => {
            if (cb.checked) {
                state.settings.targets.add(cb.value);
            } else {
                state.settings.targets.delete(cb.value);
                if (!ensureAtLeastOne(state.settings.targets, cb)) {
                    return;
                }
            }
        });
    });

    modeRadios.forEach(radio => {
        radio.addEventListener("change", () => {
            if (radio.checked) {
                state.settings.mode = radio.value;
                updateModeInfo();
                if (modes[radio.value].timer && state.currentTask) {
                    startTask();
                } else if (!modes[radio.value].timer) {
                    clearTimer();
                }
            }
        });
    });

    function getEligibleShapes() {
        return Array.from(state.settings.shapes).filter(shapeKey => {
            const validTargets = shapeConfig[shapeKey].targets.filter(target => state.settings.targets.has(target));
            return validTargets.length > 0;
        });
    }

    function pickRandom(list) {
        return list[Math.floor(Math.random() * list.length)];
    }

    function startTask() {
        const shapes = getEligibleShapes();
        if (!shapes.length) {
            showFeedback(false, "Bitte wähle mindestens einen Flächentyp und eine passende Abfrage.");
            return;
        }
        clearTimer();
        state.solved = false;
        elements.checkBtn.disabled = false;
        elements.answerInput.disabled = false;
        state.attempts = 0;
        elements.feedback.textContent = "";
        elements.feedback.className = "feedback";
        const shapeKey = pickRandom(shapes);
        const config = shapeConfig[shapeKey];
        const unit = units[Math.floor(Math.random() * units.length)];
        const generated = config.generate(unit);
        const targets = config.targets.filter(target => state.settings.targets.has(target));
        const target = pickRandom(targets);
        const taskData = config.prepare(target, generated, unit);
        const identifyList = typeof config.identify === "function" ? config.identify(generated.params, target) : [];
        let sideMapping = assignLetters(identifyList);
        const customMapping = getCustomMapping(shapeKey);
        if (customMapping) {
            sideMapping = customMapping;
        }
        state.currentTask = {
            shapeKey,
            target,
            config,
            params: generated.params,
            prompt: taskData.prompt,
            given: taskData.given,
            highlight: taskData.highlight,
            hint: taskData.hint,
            unitSuffix: taskData.unitSuffix,
            unit,
            formula: config.formula,
            identify: identifyList,
            sideMapping
        };
        state.mappingSolved = identifyList.length === 0;
        state.userSelections = {};
        state.correctValue = taskData.correctValue;
        state.unitSuffix = taskData.unitSuffix;
        elements.unitLabel.textContent = taskData.unitSuffix;
        renderTask();
        updateModeInfo();
        if (modes[state.settings.mode].timer) {
            startTimer(modes[state.settings.mode].timer);
        }
        elements.answerInput.value = "";
        elements.answerInput.focus();
    }
    function renderTask() {
        if (!state.currentTask) return;
        const config = state.currentTask.config;
        elements.taskTitle.textContent = `${config.label}: ${targetLabels[state.currentTask.target] ?? "A"} gesucht`;
        elements.taskPrompt.textContent = state.currentTask.prompt;
        const sideMapping = state.currentTask.sideMapping || {};
        elements.givenValues.innerHTML = state.currentTask.given.map(entry => {
            const isSide = entry.type === "side";
            const mappedSymbol = isSide ? (sideMapping[entry.key] || "?") : (entry.display || entry.key || "");
            const color = isSide ? getLetterColor(mappedSymbol) : (entry.display ? (extraColors[entry.display] || "var(--fg)") : "var(--fg)");
            const valueText = typeof entry.value === "number" ? formatNumber(entry.value) : entry.value;
            const unit = entry.unit || "";
            let leftContent = "";
            let liStyle = "";
            if (isSide) {
                const baseLabel = (entry.label || "").trim();
                const words = baseLabel.toLowerCase().split(/\s+/).filter(Boolean);
                const symbolLower = mappedSymbol?.toLowerCase();
                const hasLetterInLabel = symbolLower && words.includes(symbolLower);
                const labelWithLetter = (!mappedSymbol || mappedSymbol === "?")
                    ? baseLabel
                    : hasLetterInLabel ? baseLabel : `${baseLabel} ${mappedSymbol}`;
                leftContent = `<span class="given-side-label">${labelWithLetter}</span>`;
                liStyle = ` style="color:${color}"`;
            } else {
                leftContent = `<span><span class="given-symbol" style="color:${color}">${mappedSymbol || ""}</span> ${entry.label}</span>`;
            }
            return `<li${liStyle}>${leftContent}<span>${valueText} ${unit}</span></li>`;
        }).join("");
        elements.drawing.innerHTML = config.draw(state.currentTask.params, state.currentTask.unit, state.currentTask.highlight, sideMapping);
        renderSideSelection();
        const mode = modes[state.settings.mode];
        if (mode.showHints) {
            elements.formulaHint.classList.remove("hidden");
            elements.formulaHint.innerHTML = `<strong>${config.formula}</strong><br><span style="color:var(--muted)">${state.currentTask.hint}</span>`;
        } else {
            elements.formulaHint.classList.add("hidden");
            elements.formulaHint.textContent = "";
        }
    }

    function renderSideSelection() {
        const identifyList = state.currentTask?.identify ?? [];
        if (!identifyList.length) {
            elements.sideSelection.classList.add("hidden");
            elements.sideSelectionFields.innerHTML = "";
            elements.sideSelectionMessage.textContent = "";
            return;
        }
        const sideMapping = state.currentTask.sideMapping || {};
const letters = [...new Set(Object.values(sideMapping))].sort((a, b) =>
    a.localeCompare(b, "de", { sensitivity: "base" })
);
        elements.sideSelection.classList.remove("hidden");
        elements.sideSelection.classList.remove("error", "success");
        if (state.mappingSolved) {
            elements.sideSelection.classList.add("success");
        }
        elements.sideSelectionMessage.textContent = state.mappingSolved ? "Zuordnung korrekt! Jetzt Ergebnis berechnen." : "Ordne zu, welche Seite Grundseite bzw. Höhe ist.";
        elements.sideSelectionFields.innerHTML = identifyList.map(item => {
            const correctLetter = sideMapping[item.key];
            const currentValue = state.mappingSolved ? correctLetter : (state.userSelections[item.key] || "");
            const options = ['<option value="">– auswählen –</option>', ...letters.map(letter => `<option value="${letter}" ${currentValue === letter ? "selected" : ""}>${letter}</option>`)].join("");
            return `<label class="side-select">${item.label}<select data-key="${item.key}">${options}</select></label>`;
        }).join("");
        elements.sideSelectionFields.querySelectorAll("select").forEach(select => {
            select.disabled = state.mappingSolved;
        });
    }

    function validateSideSelection() {
        if (state.mappingSolved) return true;
        const identifyList = state.currentTask?.identify ?? [];
        if (!identifyList.length) {
            state.mappingSolved = true;
            return true;
        }
        for (const item of identifyList) {
            if (!state.userSelections[item.key]) {
                elements.sideSelection.classList.add("error");
                elements.sideSelectionMessage.textContent = `${item.label} fehlt noch.`;
                showFeedback(false, `Ordne zuerst ${item.label} zu.`);
                return false;
            }
        }
        const errors = identifyList.filter(item => state.userSelections[item.key] !== state.currentTask.sideMapping[item.key]);
        if (errors.length) {
            elements.sideSelection.classList.add("error");
            elements.sideSelectionMessage.textContent = "Zuordnung stimmt noch nicht.";
            showFeedback(false, "Die Variablen-Zuordnung ist noch falsch.");
            return false;
        }
        state.mappingSolved = true;
        state.userSelections = {};
        renderSideSelection();
        return true;
    }

    function parseInput() {
        const raw = elements.answerInput.value.trim();
        if (!raw) return null;
        const normalized = raw.replace(",", ".");
        const value = Number(normalized);
        if (!Number.isFinite(value)) return null;
        const decimals = normalized.includes(".") ? normalized.split(".")[1].length : 0;
        return { value, raw, decimals };
    }

    function valuesMatch(user, exact, decimals) {
        const epsilon = 1e-6;
        if (Math.abs(user - exact) < epsilon) return true;
        if (decimals >= 0) {
            const rounded = Number(exact.toFixed(decimals));
            return Math.abs(user - rounded) < epsilon;
        }
        return false;
    }

    function checkAnswer(timeout = false) {
        if (!state.currentTask) return;
        if (state.solved && !timeout) return;
        const modeKey = state.settings.mode;
        const mode = modes[modeKey];
        if (timeout) {
            showFeedback(false, "Die Zeit ist abgelaufen.");
            addHistory(false, null, true);
            state.streak = 0;
            updateStreak();
            state.solved = true;
            elements.checkBtn.disabled = true;
            elements.answerInput.disabled = true;
            if (modeKey === "timer") {
                setTimeout(startTask, 1500);
            }
            return;
        }
        if (!state.mappingSolved && !validateSideSelection()) {
            return;
        }
        const userInput = parseInput();
        if (!userInput) {
            showFeedback(false, "Bitte gib eine Zahl ein (Komma oder Punkt erlaubt).");
            return;
        }
        state.attempts += 1;
        const isCorrect = valuesMatch(userInput.value, state.correctValue, userInput.decimals);
        if (isCorrect) {
            state.solved = true;
            elements.checkBtn.disabled = true;
            elements.answerInput.disabled = true;
            if (mode.timer) {
                clearTimer();
            }
            showFeedback(true, `Richtig! ${targetLabels[state.currentTask.target] ?? "A"} = ${formatNumber(state.correctValue)} ${state.unitSuffix}`);
            addHistory(true, userInput.value);
            state.streak += 1;
            updateStreak();
            if (modeKey === "challenge" || modeKey === "timer") {
                setTimeout(startTask, 1400);
            }
        } else {
            showFeedback(false, mode.showHints ? "Überprüfe deine Formel oder runde korrekt." : "Leider falsch.");
            addHistory(false, userInput.value);
            state.streak = 0;
            updateStreak();
            if (state.attempts >= mode.maxAttempts) {
                revealSolution(true);
            }
        }
    }
    function showFeedback(isCorrect, message) {
        elements.feedback.textContent = message;
        elements.feedback.className = `feedback ${isCorrect ? "good" : "bad"}`;
    }

    function addHistory(isCorrect, userValue, timedOut = false) {
        const entry = {
            label: shapeConfig[state.currentTask.shapeKey].label,
            target: targetLabels[state.currentTask.target] || "A",
            mode: modes[state.settings.mode].label,
            user: userValue,
            correct: state.correctValue,
            unit: state.unitSuffix,
            isCorrect,
            timedOut
        };
        state.history.unshift(entry);
        if (state.history.length > 8) state.history.pop();
        renderHistory();
    }

    function renderHistory() {
        if (!state.history.length) {
            elements.historyList.innerHTML = "<li>Noch keine Versuche.</li>";
            return;
        }
        elements.historyList.innerHTML = state.history.map(item => {
            const icon = item.timedOut ? "⏱" : item.isCorrect ? "✔" : "✖";
            const answer = item.user === null ? "—" : `${formatNumber(item.user)} ${item.unit}`;
            return `<li><span>${icon} ${item.label} · ${item.target}</span><span>${answer} → ${formatNumber(item.correct)} ${item.unit}</span></li>`;
        }).join("");
    }

    function revealSolution(autoNext = false) {
        if (!state.currentTask) return;
        clearTimer();
        state.solved = true;
        if (!state.mappingSolved) {
            state.mappingSolved = true;
            renderSideSelection();
        }
        elements.checkBtn.disabled = true;
        elements.answerInput.disabled = true;
        showFeedback(false, `Die korrekte Lösung: ${targetLabels[state.currentTask.target] ?? "A"} = ${formatNumber(state.correctValue)} ${state.unitSuffix}`);
        elements.answerInput.value = formatNumber(state.correctValue);
        state.streak = 0;
        updateStreak();
        if (autoNext) {
            setTimeout(startTask, 1600);
        }
    }

    function updateModeInfo() {
        const mode = modes[state.settings.mode];
        elements.modeInfo.textContent = `${mode.label}: ${mode.description}`;
        if (mode.timer) {
            elements.timerDisplay.classList.remove("hidden");
            elements.timerDisplay.textContent = `⏱ ${mode.timer} s`;
        } else if (!state.timerId) {
            elements.timerDisplay.classList.add("hidden");
        }
    }

    function updateStreak() {
        elements.streakDisplay.textContent = `Serie: ${state.streak}`;
    }

    function startTimer(seconds) {
        state.timeLeft = seconds;
        updateTimerLabel();
        state.timerId = setInterval(() => {
            state.timeLeft -= 1;
            updateTimerLabel();
            if (state.timeLeft <= 0) {
                clearTimer();
                checkAnswer(true);
            }
        }, 1000);
    }

    function updateTimerLabel() {
        elements.timerDisplay.classList.remove("hidden");
        elements.timerDisplay.textContent = `⏱ ${state.timeLeft}s`;
    }

    function clearTimer() {
        if (state.timerId) {
            clearInterval(state.timerId);
            state.timerId = null;
        }
    }

    elements.settingsBtn.addEventListener("click", () => toggleSettings(true));
    elements.settingsBackdrop.addEventListener("click", () => toggleSettings(false));
    elements.closeSettings.addEventListener("click", () => toggleSettings(false));

    elements.newTaskBtn.addEventListener("click", startTask);
    elements.checkBtn.addEventListener("click", () => checkAnswer(false));
    elements.giveUpBtn.addEventListener("click", () => revealSolution(false));

    elements.answerInput.addEventListener("keydown", event => {
        if (event.key === "Enter") {
            checkAnswer(false);
        }
    });

    elements.sideSelectionFields.addEventListener("change", event => {
        if (event.target.matches("select[data-key]")) {
            state.userSelections[event.target.dataset.key] = event.target.value;
            elements.sideSelection.classList.remove("error");
        }
    });

    document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
            clearTimer();
        }
    });
</script>
</body>
</html>
