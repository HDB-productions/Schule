<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wellenpakete – 2-Wellen & Mehrkomponenten (Unschärferelation)</title>
<style>
  :root{
    --bg:#0f1116; --panel:#121722; --grid:#273041; --axis:#cbd5e1;
    --text:#e6e6e6; --muted:#94a3b8; --env:#5e90c9;
  }
  body{margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;display:grid;place-items:center;padding:18px}
  .wrap{width:min(1024px,96vw)}
  h1{font-size:20px;margin:0 0 10px}
  h2{font-size:18px;margin:18px 0 8px}
  .row{display:flex;gap:14px;align-items:center;flex-wrap:wrap;margin:8px 0}
  label{font-weight:600}
  .note{font-size:14px;color:var(--muted)}
  canvas{width:100%;height:auto;background:var(--panel);border-radius:12px;box-shadow:0 6px 24px #0007}
  .legend{display:flex;gap:18px;flex-wrap:wrap;margin-top:8px;font-size:14px;color:var(--muted)}
  .sw{display:inline-flex;align-items:center;gap:8px}
  .dot{width:16px;height:4px;border-radius:2px;display:inline-block}
  .a{background:var(--colA)}
  .b{background:var(--colB)}
  .s{background:var(--colSum)}
  .e{background:var(--env)}
  .comp{background:#888}
  .panel{margin-top:10px}
  .ctrl input[type=range]{width:min(420px,78vw); -webkit-appearance:none; appearance:none; height:4px; background:#2a3346; border-radius:2px; outline:none}
  .ctrl input[type=range]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:18px; height:18px; border-radius:50%;
    background: var(--thumb, #888); border:2px solid #000; box-shadow:0 0 0 3px rgba(0,0,0,.25);
  }
  .ctrl input[type=range]::-moz-range-thumb{
    width:18px; height:18px; border-radius:50%; background: var(--thumb, #888);
    border:2px solid #000; box-shadow:0 0 0 3px rgba(0,0,0,.25);
  }
  .ctrl{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .sep{height:1px;background:#223046;margin:14px 0}
</style>
</head>
<body>
<div class="wrap">
  <h1>Warum lassen sich Ort und Impuls nicht zeitgleich exakt bestimmen?</h1>

  <!-- PANEL 1: Zwei-Wellen-Schwebung -->
  <h2>Panel 1 – Zwei Wellen (Schwebung)</h2>
  <div class="row ctrl">
    <label for="lambda1">λ₁:</label>
    <input id="lambda1" type="range" min="0.38" max="0.75" step="0.002" value="0.50" />
    <output id="lamOut1">0,50&nbsp;µm</output>
    <label for="lambda2">λ₂:</label>
    <input id="lambda2" type="range" min="0.38" max="0.75" step="0.002" value="0.50" />
    <output id="lamOut2">0,50&nbsp;µm</output>
    <label><input id="showSingles12" type="checkbox" checked /> Einzelwellen anzeigen</label>
    <div class="note">x ∈ [−2 µm, +2 µm], Phase 0 im Ursprung, Amplituden ±1</div>
  </div>
  <canvas id="cv12" class="panel" width="1000" height="420"></canvas>
  <div class="legend">
    <span class="sw"><i class="dot a"></i>Einzelwelle Ψ₁ (λ₁)</span>
    <span class="sw"><i class="dot b"></i>Einzelwelle Ψ₂ (λ₂)</span>
    <span class="sw"><i class="dot s"></i>Summe Ψ = Ψ₁ + Ψ₂</span>
    <span class="sw"><i class="dot e"></i>Einhüllende</span>
  </div>

  <div class="sep"></div>

  <!-- PANEL 2: Mehrkomponenten-Paket -->
  <h2>Panel 2 – Mehrkomponenten-Wellenpaket (N Wellen)</h2>
  <div class="row ctrl">
    <label for="lambda0">λ₀ (Mitte):</label>
    <input id="lambda0" type="range" min="0.38" max="0.75" step="0.002" value="0.50" />
    <output id="lamOut0">0,50&nbsp;µm</output>
    <label for="band">Δλ (Bandbreite):</label>
    <input id="band" type="range" min="0.002" max="0.50" step="0.002" value="0.040" />
    <output id="bandOut">0,040&nbsp;µm</output>
  </div>
  <div class="row ctrl">
    <label for="num">Anzahl N:</label>
    <input id="num" type="range" min="2" max="200" step="2" value="40" />
    <output id="numOut">40</output>
    <label for="phaseMode">Phasen:</label>
    <select id="phaseMode">
      <option value="coherent">alle 0 (kohärent)</option>
      <option value="random">zufällig [0,2π)</option>
    </select>
    <label><input id="showSinglesN" type="checkbox" /> Einzelkomponenten anzeigen</label>
  </div>
  <canvas id="cvN" class="panel" width="1000" height="420"></canvas>
  <div class="legend">
    <span class="sw"><i class="dot comp"></i>Einzelkomponente (optional)</span>
    <span class="sw"><i class="dot s"></i>Resultierende ΣΨᵢ</span>
  </div>
</div>

<script>
(function(){
  // ------- gemeinsame Hilfen -------
  const xMin=-2, xMax=2, yMin=-1.1, yMax=1.1;
  function setupCanvas(id){
    const cv=document.getElementById(id), ctx=cv.getContext('2d');
    const W=cv.width, H=cv.height, padL=70, padR=22, padT=28, padB=46;
    const plotW=W-padL-padR, plotH=H-padT-padB;
    const toPxX=x=>padL + (x-xMin)*plotW/(xMax-xMin);
    const toPxY=y=>padT + (yMax-y)*plotH/(yMax-yMin);
    function getCss(v){return getComputedStyle(document.documentElement).getPropertyValue(v).trim();}
    function fmt(v){return (Math.abs(v)<1e-3? "0" : v.toString().replace(".",","));}
    function grid(){
      ctx.fillStyle = getCss('--panel'); ctx.fillRect(0,0,W,H);
      ctx.strokeStyle=getCss('--grid'); ctx.lineWidth=1; ctx.beginPath();
      const xTicks=[-2,-1.5,-1,-0.5,0,0.5,1,1.5,2];
      for(const xt of xTicks){const X=toPxX(xt); ctx.moveTo(X,padT); ctx.lineTo(X,padT+plotH);}
      const yTicks=[-1,-0.5,0,0.5,1];
      for(const yt of yTicks){const Y=toPxY(yt); ctx.moveTo(padL,Y); ctx.lineTo(padL+plotW,Y);}
      ctx.stroke();
      ctx.strokeStyle=getCss('--axis'); ctx.lineWidth=1.5;
      ctx.beginPath(); ctx.moveTo(padL,toPxY(0)); ctx.lineTo(padL+plotW,toPxY(0)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(toPxX(0),padT); ctx.lineTo(toPxX(0),padT+plotH); ctx.stroke();
      ctx.fillStyle=getCss('--text'); ctx.font="14px system-ui, Segoe UI, sans-serif"; ctx.textAlign="center"; ctx.textBaseline="top";
      for(const xt of xTicks){const X=toPxX(xt); const label=(xt===0?"0":"\u2009"+fmt(xt)+"\u00a0µm"); ctx.fillText(label,X,padT+plotH+8);}
      ctx.textAlign="right"; ctx.textBaseline="middle"; ctx.fillStyle=getCss('--muted');
      for(const yt of [-1,-0.5,0,0.5,1]){const Y=toPxY(yt); ctx.fillText(fmt(yt), padL-8, Y);}
      return {xTicks:[-2,-1.5,-1,-0.5,0,0.5,1,1.5,2]};
    }
    function drawCurve(fun, color, width=2){
      ctx.strokeStyle=color; ctx.lineWidth=width; ctx.lineJoin="round"; ctx.beginPath();
      const N=1600;
      for(let i=0;i<=N;i++){
        const t=i/N, x=xMin+(xMax-xMin)*t, y=fun(x);
        const X=toPxX(x), Y=toPxY(y);
        if(i===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
    }
    return {cv,ctx,W,H,toPxX,toPxY,getCss,fmt,grid,drawCurve};
  }

  // Wellenlänge -> RGB (sichtbares Spektrum), auf Basis Dan Bruton
  function wavelengthToRGB(lambda_um){
    let nm = Math.max(380, Math.min(750, lambda_um*1000));
    let r=0,g=0,b=0;
    if (nm<440){ r=-(nm-440)/(440-380); g=0; b=1; }
    else if(nm<490){ r=0; g=(nm-440)/(490-440); b=1; }
    else if(nm<510){ r=0; g=1; b=-(nm-510)/(510-490); }
    else if(nm<580){ r=(nm-510)/(580-510); g=1; b=0; }
    else if(nm<645){ r=1; g=-(nm-645)/(645-580); b=0; }
    else          { r=1; g=0; b=0; }
    let factor=1; if(nm<420) factor=0.3+0.7*(nm-380)/(420-380); else if(nm>645) factor=0.3+0.7*(750-nm)/(750-645);
    r=Math.round(255*r*factor); g=Math.round(255*g*factor); b=Math.round(255*b*factor);
    return `rgb(${r},${g},${b})`;
  }
  function setThumbColor(inputEl, cssColor){ inputEl.style.setProperty('--thumb', cssColor); }

  // ------- Panel 1: Zwei Wellen -------
  const p1 = setupCanvas('cv12');
  const r1 = document.getElementById('lambda1');
  const r2 = document.getElementById('lambda2');
  const o1 = document.getElementById('lamOut1');
  const o2 = document.getElementById('lamOut2');
  const chk12 = document.getElementById('showSingles12');

  function render12(){
    const L1 = parseFloat(r1.value), L2=parseFloat(r2.value), A=0.5;
    o1.innerHTML=r1.value.replace(".",",")+"&nbsp;µm";
    o2.innerHTML=r2.value.replace(".",",")+"&nbsp;µm";
    const colA = wavelengthToRGB(L1), colB=wavelengthToRGB(L2);
    const lambdaEff = 2/(1/L1 + 1/L2); // harmonisches Mittel
    const colSum = wavelengthToRGB(lambdaEff);
    document.documentElement.style.setProperty('--colA', colA);
    document.documentElement.style.setProperty('--colB', colB);
    document.documentElement.style.setProperty('--colSum', colSum);
    setThumbColor(r1,colA); setThumbColor(r2,colB);

    p1.grid();
    const k1=2*Math.PI/L1, k2=2*Math.PI/L2, dK=k2-k1;
    const psi1 = x=>A*Math.sin(k1*x);
    const psi2 = x=>A*Math.sin(k2*x);
    const psis = x=>psi1(x)+psi2(x);
    const env  = x=>2*A*Math.abs(Math.cos(0.5*dK*x));
    if(chk12.checked){ p1.drawCurve(psi1, colA, 2); p1.drawCurve(psi2, colB, 2); }
    p1.drawCurve(psis, colSum, 3);
    p1.drawCurve(x=> env(x), p1.getCss('--env'), 2);
    p1.drawCurve(x=>-env(x), p1.getCss('--env'), 2);
  }
  ['input','change'].forEach(ev=>{ r1.addEventListener(ev,render12); r2.addEventListener(ev,render12); chk12.addEventListener(ev,render12); });
  render12();

  // ------- Panel 2: N-Wellen -------
  const pN = setupCanvas('cvN');
  const r0 = document.getElementById('lambda0');
  const rb = document.getElementById('band');
  const rn = document.getElementById('num');
  const o0 = document.getElementById('lamOut0');
  const ob = document.getElementById('bandOut');
  const on = document.getElementById('numOut');
  const phaseMode = document.getElementById('phaseMode');
  const chkN = document.getElementById('showSinglesN');

  function gaussian(x,mu,sigma){ const z=(x-mu)/sigma; return Math.exp(-0.5*z*z); }

  function renderN(){
    const L0=parseFloat(r0.value), dL=parseFloat(rb.value), N=parseInt(rn.value,10);
    o0.innerHTML=r0.value.replace(".",",")+"&nbsp;µm";
    ob.innerHTML=rb.value.replace(".",",")+"&nbsp;µm";
    on.innerText=N;

    // Spektralfarbe der resultierenden ≈ Farbe von λ0
    const colSum = wavelengthToRGB(L0);
    document.documentElement.style.setProperty('--colSum', colSum);
    setThumbColor(r0, colSum);

    pN.grid();

    // Erzeuge N Wellen um λ0 mit Gaußgewicht im k-Raum (≈ Gauß in λ bei kleiner Bandbreite)
    // Wir sampeln gleichmäßig in λ in [λ0-Δλ/2, λ0+Δλ/2]
    const Lmin=Math.max(0.38, L0-dL/2), Lmax=Math.min(0.75, L0+dL/2);
    const lamList=[];
    for(let i=0;i<N;i++){
      const t=(N===1)?0.5:i/(N-1);
      lamList.push(Lmin + (Lmax-Lmin)*t);
    }
    // Gewichte: Gauß in λ (didaktisch ok). σ so wählen, dass 95% im Fenster liegen.
    const sigma=dL/4; // 4σ ≈ Bandbreite
    const weights=lamList.map(L=>gaussian(L,L0,sigma));
    // Normiere auf Summe der Amplituden = 1 (damit y-Skala bleibt)
    const sumW = weights.reduce((a,b)=>a+b,0);
    const A0 = 1.0/sumW; // Gesamtamplitude ~1

    const randPhase = (phaseMode.value==='random');

    // Precompute Komponentenfunktionen
    const comps = lamList.map((L,i)=>{
      const k=2*Math.PI/L;
      const phi = randPhase ? Math.random()*2*Math.PI : 0;
      const amp = A0 * weights[i];
      return {L,k,phi,amp, color: chkN.checked ? wavelengthToRGB(L) : null};
    });

    // Resultierende
    const psiSum = x => comps.reduce((acc,c)=> acc + c.amp*Math.sin(c.k*x + c.phi), 0);

    // Zeichne Komponenten (dünn)
    if(chkN.checked){
      for(const c of comps){
        pN.drawCurve(x => c.amp*Math.sin(c.k*x + c.phi), c.color, 1);
      }
    }
    // Zeichne Summe
    pN.drawCurve(psiSum, colSum, 3);
  }

  ['input','change'].forEach(ev=>{
    r0.addEventListener(ev,renderN);
    rb.addEventListener(ev,renderN);
    rn.addEventListener(ev,renderN);
    phaseMode.addEventListener(ev,renderN);
    chkN.addEventListener(ev,renderN);
  });
  renderN();
})();
</script>
</body>
</html>
